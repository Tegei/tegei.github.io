'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var _slicedToArray = _interopDefault(require('@babel/runtime/helpers/slicedToArray'));
var React = require('react');
var React__default = _interopDefault(React);
var reactThreeFiber = require('react-three-fiber');
var merge = _interopDefault(require('lodash.merge'));
var three = require('three');
var OrbitControls = _interopDefault(require('three-orbitcontrols'));
var hexRgb = _interopDefault(require('hex-rgb'));
var isHex = _interopDefault(require('is-hexcolor'));

/* eslint-disable no-shadow */

/* eslint-disable no-plusplus */

/* eslint-disable no-continue */

/* eslint-disable no-param-reassign */

/**
 * Calculate new velocity/position of current particle if it hits x, y, or z boundary
 *
 * Controlled by boundaryType, either 'bounce' or 'passthru'
 */
var handleBoundary = function handleBoundary(_ref) {
  var bounds = _ref.bounds,
      boundaryType = _ref.boundaryType,
      particlePositions = _ref.particlePositions,
      particleData = _ref.particleData,
      i = _ref.i;
  // Get the boundary points of the canvas
  // Useful for knowing when a particle is at the edge of the canvas
  var xBounds = bounds.xBounds,
      yBounds = bounds.yBounds,
      zBounds = bounds.zBounds; // Make the current particle "transport" from one side of boundary to the other
  // The particles feel like they 'disappear' and new ones are 'appearing'

  if (boundaryType === 'passthru') {
    // If a particle crosses the x-axis edge, send particle to the opposite x-axis edge
    if (particlePositions[i * 3] < -xBounds / 2) particlePositions[i * 3] = xBounds / 2;else if (particlePositions[i * 3] > xBounds / 2) particlePositions[i * 3] = -xBounds / 2; // If a particle crosses the y-axis edge, send particle to the opposite y-axis edge

    if (particlePositions[i * 3 + 1] < -yBounds / 2) particlePositions[i * 3 + 1] = yBounds / 2;else if (particlePositions[i * 3 + 1] > yBounds / 2) particlePositions[i * 3 + 1] = -yBounds / 2; // If a particle crosses the y-axis edge, send particle to the opposite y-axis edge

    if (particlePositions[i * 3 + 2] < -zBounds / 2) particlePositions[i * 3 + 2] = zBounds / 2;else if (particlePositions[i * 3 + 2] > zBounds / 2) particlePositions[i * 3 + 2] = -zBounds / 2;
  } else if (boundaryType === 'bounce') {
    // Make the current particle "bounce" off of the "bounds" of the canvas
    // The particles behave like balls thrown at a wall
    if (particlePositions[i * 3] < -xBounds / 2 || particlePositions[i * 3] > xBounds / 2) particleData.velocity.x = -particleData.velocity.x;
    if (particlePositions[i * 3 + 1] < -yBounds / 2 || particlePositions[i * 3 + 1] > yBounds / 2) particleData.velocity.y = -particleData.velocity.y;
    if (particlePositions[i * 3 + 2] < -zBounds / 2 || particlePositions[i * 3 + 2] > zBounds / 2) particleData.velocity.z = -particleData.velocity.z;
  }
};
/**
 * Animates an array of particles and lines over a three dimensional space
 *
 * This function is meant to be called from the useRender render loop -- ran on each frame
 */


var animate = function animate(_ref2) {
  var minDistance = _ref2.minDistance,
      limitConnections = _ref2.limitConnections,
      maxConnections = _ref2.maxConnections,
      particleCount = _ref2.particleCount,
      lineMeshGeometry = _ref2.lineMeshGeometry,
      pointCloudGeometry = _ref2.pointCloudGeometry,
      particlesData = _ref2.particlesData,
      particlePositions = _ref2.particlePositions,
      linePositions = _ref2.linePositions,
      lineColors = _ref2.lineColors,
      bounds = _ref2.bounds,
      showLines = _ref2.showLines,
      boundaryType = _ref2.boundaryType;
  var vertexpos = 0;
  var colorpos = 0;
  var numConnected = 0; // Start by assuming no line connections between particles

  for (var i = 0; i < particleCount; i += 1) {
    particlesData[i].numConnections = 0;
  } // Update the [x, y, z] position of each particle


  for (var _i = 0; _i < particleCount; _i += 1) {
    // The current particle
    var particleData = particlesData[_i];
    particlePositions[_i * 3] += particleData.velocity.x;
    particlePositions[_i * 3 + 1] += particleData.velocity.y;
    particlePositions[_i * 3 + 2] += particleData.velocity.z; // Calculate new velocity/position of current particle if it hits x, y, or z boundary
    // Controlled by boundaryType, either 'bounce' or 'passthru'

    handleBoundary({
      bounds: bounds,
      boundaryType: boundaryType,
      particlePositions: particlePositions,
      particleData: particleData,
      i: _i
    }); // Skip to next particle if we are intentionally not drawing lines

    if (!showLines || limitConnections && particleData.numConnections >= maxConnections) continue; // Calculate the distance between particles to find nearest-neighbors
    // If particles fall within the threshold, draw a line connecting them

    for (var j = _i + 1; j < particleCount; j += 1) {
      // The "other" particle to compare to "this" one
      var particleDataB = particlesData[j]; // Skip to next particle(don't draw more lines) if some limiting factor has been met

      if (limitConnections && particleDataB.numConnections >= maxConnections) continue; // Calculate the distance between "this" particle and the "other" particle

      var dx = particlePositions[_i * 3] - particlePositions[j * 3];
      var dy = particlePositions[_i * 3 + 1] - particlePositions[j * 3 + 1];
      var dz = particlePositions[_i * 3 + 2] - particlePositions[j * 3 + 2];
      var dist = Math.sqrt(dx * dx + dy * dy + dz * dz); // If "this" particle is close enough to the "other" particle, draw a line connecting the two

      if (dist < minDistance) {
        // Increment the number of connections by one on both particles
        particleData.numConnections += 1;
        particleDataB.numConnections += 1; // The lines become more transparent the further apart the particles become
        // The line fragment shader applies this alpha attribute when coloring the lines

        var alpha = 1.0 - dist / minDistance; // Set the line position's [x, y, z] position at "this" point and the "other" point

        linePositions[vertexpos++] = particlePositions[_i * 3];
        linePositions[vertexpos++] = particlePositions[_i * 3 + 1];
        linePositions[vertexpos++] = particlePositions[_i * 3 + 2];
        linePositions[vertexpos++] = particlePositions[j * 3];
        linePositions[vertexpos++] = particlePositions[j * 3 + 1];
        linePositions[vertexpos++] = particlePositions[j * 3 + 2];
        lineColors[colorpos++] = alpha;
        lineColors[colorpos++] = alpha;
        lineColors[colorpos++] = alpha;
        lineColors[colorpos++] = alpha;
        lineColors[colorpos++] = alpha;
        lineColors[colorpos++] = alpha;
        numConnected += 1;
      }
    }
  } // Signal to Three.js that the line and point geometry have changed


  lineMeshGeometry.setDrawRange(0, numConnected * 2);
  lineMeshGeometry.attributes.position.needsUpdate = true;
  lineMeshGeometry.attributes.color.needsUpdate = true;
  pointCloudGeometry.attributes.position.needsUpdate = true;
};

/**
 * Converts a hex color to gl_FragColor format
 *
 * @param {string} color A hex color
 */

var genColorFromHex = function genColorFromHex(_ref) {
  var color = _ref.color;
  if (!isHex(color)) return "1, 1, 1";

  var _hexRgb = hexRgb(color),
      red = _hexRgb.red,
      green = _hexRgb.green,
      blue = _hexRgb.blue;

  return "".concat((red / 255).toFixed(2), ", ").concat((green / 255).toFixed(2), ", ").concat((blue / 255).toFixed(2));
};
/**
 * Line shader color for solid colors option
 *
 * @param {string} color A hex color
 */


var solidLineColors = function solidLineColors(_ref2) {
  var color = _ref2.color;
  return "\n  vColor = vec3(".concat(genColorFromHex({
    color: color
  }), ");\n");
};
/**
 * Line shader color for rainbow colors option
 */


var rainbowLineColors = "\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n  vColor = normalize( abs( worldPosition.xyz ) );\n";
/**
 * Generates a vertex shader for a connecting line in a particle system
 *
 * This shader uses the position of particles to determine their color
 * and change them as they move
 */

var getLineVertexShader = function getLineVertexShader(_ref3) {
  var colorMode = _ref3.colorMode,
      color = _ref3.color;
  return "\n// Amount of transparency for line, calculated in Animate\nattribute float color;\n\n// Calculate color based on line position\nvarying vec3 vColor;\nvarying float alpha;\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  ".concat(colorMode === 'rainbow' ? rainbowLineColors : '', "\n  ").concat(colorMode === 'solid' ? solidLineColors({
    color: color
  }) : '', "\n  alpha = color;\n}\n");
};
/**
 * Applies a color to a connecting line in a particle system
 */

var getLineFragmentShader = function getLineFragmentShader(_ref4) {
  var transparency = _ref4.transparency;
  return "\n// Color calculated from vertex shader, based on line position\nvarying vec3 vColor;\n// Amount of transparency from vertex shader, based on distance between particles\nvarying float alpha;\n\nvoid main() {\n  gl_FragColor = vec4( vColor, alpha * ".concat(transparency, ");\n}\n");
};

var computeLines = (function (_ref) {
  var particles = _ref.particles,
      lines = _ref.lines;
  var count = particles.count;
  var color = lines.color,
      colorMode = lines.colorMode,
      transparency = lines.transparency,
      visible = lines.visible; // Line material

  var lineMeshMaterial = new three.ShaderMaterial({
    vertexShader: getLineVertexShader({
      colorMode: colorMode,
      color: color
    }),
    fragmentShader: getLineFragmentShader({
      transparency: transparency
    }),
    transparent: true,
    blending: three.AdditiveBlending,
    visible: visible
  }); // Line mesh geometry

  var lineMeshGeometry = new three.BufferGeometry();
  var segments = count * count;
  var positions = new Float32Array(segments * 3);
  var colors = new Float32Array(segments * 3);
  lineMeshGeometry.addAttribute('position', new three.BufferAttribute(positions, 3).setDynamic(true));
  lineMeshGeometry.addAttribute('color', new three.BufferAttribute(colors, 3).setDynamic(true));
  lineMeshGeometry.computeBoundingSphere();
  lineMeshGeometry.setDrawRange(0, 0);
  return [lineMeshGeometry, lineMeshMaterial, positions, colors];
});

/**
 * Converts a hex color to gl_FragColor format
 *
 * @param {string} color A hex color
 */

var genColorFromHex$1 = function genColorFromHex(_ref) {
  var color = _ref.color;
  if (!isHex(color)) return "1, 1, 1";

  var _hexRgb = hexRgb(color),
      red = _hexRgb.red,
      green = _hexRgb.green,
      blue = _hexRgb.blue;

  return "".concat((red / 255).toFixed(2), ", ").concat((green / 255).toFixed(2), ", ").concat((blue / 255).toFixed(2));
};
/**
 * Vertex shader color for solid colors option
 *
 * @param {string} color A hex color
 */


var solidVertexColors = function solidVertexColors(_ref2) {
  var color = _ref2.color;
  return "\n  vColor = vec3(".concat(genColorFromHex$1({
    color: color
  }), ");\n");
};
/**
 * Vertex shader color for rainbow colors option
 */


var rainbowVertextColors = "\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n  vColor = vec3( normalize( abs( worldPosition.xyz ) ));\n";
/**
 * Generates a vertex shader for a particle system
 *
 * This shader uses the position of particles to determine their color
 * and change them as they move
 */

var getParticleVertexShader = function getParticleVertexShader(_ref3) {
  var colorMode = _ref3.colorMode,
      color = _ref3.color,
      devicePixelRatio = _ref3.devicePixelRatio;
  return "\n// Size attribute for particle geometry\nattribute float size;\n\n// Calculate color based on particle position\nvarying vec3 vColor;\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_PointSize = size * ( 300.0 / -mvPosition.z ) * ".concat(devicePixelRatio, ";\n  gl_Position = projectionMatrix * mvPosition;\n\n  ").concat(colorMode === 'rainbow' ? rainbowVertextColors : '', "\n  ").concat(colorMode === 'solid' ? solidVertexColors({
    color: color
  }) : '', "\n}\n");
}; // "Cuts" a circle out of the default square shape
// by setting the "leftovers" as transparent

var circleParticleShape = "\nfloat r = 0.0, delta = 0.0, alpha = 1.0;\nvec2 cxy = 2.0 * gl_PointCoord - 1.0;\nr = dot(cxy, cxy);\nif (r > 1.0) {\n    discard;\n}\n";
/**
 * Applies a shape to each particle
 *
 * @param {String} particleShape Either 'circle' or 'square'
 * @param {Number} transparency The alpha channel rgba value for particles
 */

var getParticleFragmentShader = function getParticleFragmentShader(_ref4) {
  var particleShape = _ref4.particleShape,
      transparency = _ref4.transparency;
  return "\n// Color from uniforms arg\nuniform vec3 color;\n\n// Color calculated from vertex shader, based on particle position\nvarying vec3 vColor;\n\nvoid main() {\n  ".concat(particleShape === 'circle' ? circleParticleShape : '', "\n  gl_FragColor = vec4(vColor, ").concat(transparency, ");\n}\n");
};

var computeParticles = (function (_ref) {
  var particles = _ref.particles,
      dimension = _ref.dimension,
      devicePixelRatio = _ref.devicePixelRatio,
      direction = _ref.direction,
      size = _ref.size,
      r = _ref.r,
      velocity = _ref.velocity;
  var boundingBox = particles.boundingBox,
      count = particles.count,
      colorMode = particles.colorMode,
      color = particles.color,
      shape = particles.shape,
      transparency = particles.transparency,
      minSize = particles.minSize,
      maxSize = particles.maxSize,
      visible = particles.visible; // Add particles to geometry
  // Maintain two arrays
  // particlePositions contains random x,y,z coords for each particle
  // particlesData contains a random x,y,z velocity vector for each particle

  var pointCloudGeometry = new three.BufferGeometry();
  var particlePositions = new Float32Array(count * 3);
  var particleSizes = new Float32Array(count);
  var particlesData = [];
  var xBounds;
  var yBounds;
  var zBounds;

  if (boundingBox === 'canvas') {
    // Adjust size of particle field contstraints based on
    // whether field is 2D or 3D
    xBounds = dimension === '2D' ? size.width : size.width;
    yBounds = dimension === '2D' ? size.height : size.height * 1.5;
    zBounds = dimension === '2D' ? 0 : size.width;
  }

  if (boundingBox === 'cube') {
    xBounds = r;
    yBounds = r;
    zBounds = dimension === '2D' ? 0 : r;
  }

  for (var i = 0; i < count; i += 1) {
    // Calculate possible (x, y, z) location of particle
    // within the size of the canvas or cube size
    var x = Math.random() * xBounds - xBounds / 2;
    var y = Math.random() * yBounds - yBounds / 2;
    var z = Math.random() * zBounds - zBounds / 2;
    particlePositions[i * 3] = x;
    particlePositions[i * 3 + 1] = y;
    particlePositions[i * 3 + 2] = z; // Choose size of each particle

    particleSizes[i] = Math.random() * (maxSize - minSize) + minSize; // Calculates a random number between given range

    var getVelocityMultiplier = function getVelocityMultiplier(min, max) {
      return Math.random() * (max - min) + min;
    };

    var xMin = direction.xMin,
        xMax = direction.xMax,
        yMin = direction.yMin,
        yMax = direction.yMax,
        zMin = direction.zMin,
        zMax = direction.zMax;
    particlesData.push({
      velocity: new three.Vector3(getVelocityMultiplier(xMin, xMax) * velocity, getVelocityMultiplier(yMin, yMax) * velocity, getVelocityMultiplier(zMin, zMax) * velocity),
      numConnections: 0
    });
  }

  pointCloudGeometry.setDrawRange(0, count);
  pointCloudGeometry.addAttribute('position', new three.BufferAttribute(particlePositions, 3).setDynamic(true));
  pointCloudGeometry.addAttribute('size', new three.BufferAttribute(particleSizes, 1).setDynamic(true)); // Material for particle, use shaders to morph shape and color

  var pointMaterial = new three.ShaderMaterial({
    vertexShader: getParticleVertexShader({
      colorMode: colorMode,
      color: color,
      devicePixelRatio: devicePixelRatio
    }),
    fragmentShader: getParticleFragmentShader({
      particleShape: shape,
      transparency: transparency
    }),
    transparent: transparency < 1,
    blending: three.AdditiveBlending,
    visible: visible
  }); // The x,y,z bounds of possible particle positions
  // needed for Animate function

  var bounds = {
    xBounds: xBounds,
    yBounds: yBounds,
    zBounds: zBounds
  };
  return [pointCloudGeometry, pointMaterial, particlesData, particlePositions, bounds];
});

var r = 400;
/**
 * Creates a particle cloud with various config options
 */

var ParticleField = function ParticleField(_ref) {
  var particles = _ref.particles,
      lines = _ref.lines,
      direction = _ref.direction,
      showCube = _ref.showCube,
      cameraControls = _ref.cameraControls,
      dimension = _ref.dimension,
      velocity = _ref.velocity,
      boundaryType = _ref.boundaryType;
  var controlsRef = React.useRef(0);
  var animation = React.useRef(0);
  var group = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      canvas = _useThree.canvas,
      camera = _useThree.camera,
      size = _useThree.size; // Scale rendering automatically to window DPI
  // Pass this value to fragment shaders: gl_PointSize needs to scale against this value
  // https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setPixelRatio


  var devicePixelRatio = window.devicePixelRatio.toFixed(1);
  gl.setPixelRatio(devicePixelRatio); // Default distance from camera to particle field

  var distToParticles = 1750; // Setup camera

  controlsRef.current = React.useMemo(function () {
    var aspectRatio = size.width / size.height; // Calculates the proper FOV for 2D particle field to
    // perfectly fill canvas

    var cameraFOV = 2 * Math.atan(size.width / aspectRatio / (2 * distToParticles)) * (180 / Math.PI);
    camera.fov = cameraFOV;
    camera.aspect = aspectRatio;
    camera.near = 1; // Allow field to stay in view while zooming really far out

    camera.far = 10000; // Remove event listeners from previous controls if they exist
    // Set initial camera position if controls haven't taken over yet

    if (controlsRef.current) controlsRef.current.dispose();else camera.position.set(0, 0, distToParticles); // Setup movement controls for mouse/touch to manipulate camera position
    // https://threejs.org/docs/#examples/controls/OrbitControls

    var controls = new OrbitControls(camera, canvas); // Apply given settings to camera controls

    Object.entries(cameraControls).forEach(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          key = _ref3[0],
          value = _ref3[1];

      controls[key] = value;
    });
    return controls;
  }, [camera, cameraControls, canvas, size.height, size.width]); // When the resetCameraFlag option is toggled to 'true', reset camera position

  if (cameraControls.resetCameraFlag === true) {
    camera.position.set(0, 0, 1750);
  } // Compute lines between points


  var _useMemo = React.useMemo(function () {
    return computeLines({
      particles: particles,
      lines: lines
    });
  }, [particles, lines]),
      _useMemo2 = _slicedToArray(_useMemo, 4),
      lineMeshGeometry = _useMemo2[0],
      lineMeshMaterial = _useMemo2[1],
      linePositions = _useMemo2[2],
      lineColors = _useMemo2[3]; // Compute point cloud


  var _useMemo3 = React.useMemo(function () {
    return computeParticles({
      particles: particles,
      dimension: dimension,
      devicePixelRatio: devicePixelRatio,
      direction: direction,
      size: size,
      r: r,
      velocity: velocity
    });
  }, [particles, dimension, direction, devicePixelRatio, size, velocity]),
      _useMemo4 = _slicedToArray(_useMemo3, 5),
      pointCloudGeometry = _useMemo4[0],
      pointMaterial = _useMemo4[1],
      particlesData = _useMemo4[2],
      particlePositions = _useMemo4[3],
      bounds = _useMemo4[4]; // Assign state to animation ref
  // This object is passed to Animation.js in render loop


  animation.current = {
    minDistance: lines.minDistance,
    limitConnections: lines.limitConnections,
    maxConnections: lines.maxConnections,
    particleCount: particles.count,
    bounds: bounds,
    lineMeshGeometry: lineMeshGeometry,
    pointCloudGeometry: pointCloudGeometry,
    particlesData: particlesData,
    particlePositions: particlePositions,
    linePositions: linePositions,
    lineColors: lineColors,
    showLines: lines.visible,
    boundaryType: boundaryType
  }; // Direct access to render loop, executes on each frame
  // State changes must be passed into hook via refs
  // useRender() contents are called in a requestAnimationFrame()

  reactThreeFiber.useRender(function () {
    // Enables damping of OrbitControls
    controlsRef.current.update(); // Animate current state of particles + lines

    animate(animation.current);
  });
  return React__default.createElement("scene", null, React__default.createElement("group", {
    ref: group
  }, showCube && React__default.createElement("boxHelper", null, React__default.createElement("mesh", {
    name: "object"
  }, React__default.createElement("meshBasicMaterial", {
    attach: "material",
    color: "white",
    blending: three.AdditiveBlending,
    wireframe: true,
    transparent: true
  }), React__default.createElement("boxBufferGeometry", {
    attach: "geometry",
    args: [r, r, r]
  }))), lines.visible && React__default.createElement("lineSegments", {
    geometry: lineMeshGeometry,
    material: lineMeshMaterial
  }), particles.visible && React__default.createElement("points", {
    geometry: pointCloudGeometry,
    material: pointMaterial
  })));
};

/**
 * The default configuation for the ParticleField component
 *
 * Any option passed in via props will overwrite the default config
 */
var initialConfig = {
  showCube: true,
  dimension: '3D',
  velocity: 2,
  boundaryType: 'bounce',
  antialias: false,
  direction: {
    xMin: -1,
    xMax: 1,
    yMin: -1,
    yMax: 1,
    zMin: -1,
    zMax: 1
  },
  lines: {
    colorMode: 'rainbow',
    color: '#351CCB',
    transparency: 0.9,
    limitConnections: true,
    maxConnections: 20,
    minDistance: 150,
    visible: true
  },
  particles: {
    colorMode: 'rainbow',
    color: '#3FB568',
    transparency: 0.9,
    shape: 'square',
    boundingBox: 'canvas',
    count: 500,
    minSize: 10,
    maxSize: 75,
    visible: true
  },
  cameraControls: {
    enabled: true,
    enableDamping: true,
    dampingFactor: 0.2,
    enableZoom: true,
    autoRotate: true,
    autoRotateSpeed: 0.3,
    resetCameraFlag: false
  }
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Creates a 2D/3D particle field with react-three-fiber, three.js and WebGL
 *
 * Documentation on the configuration object can be found in the github repo
 * @see https://github.com/tim-soft/react-particles-webgl
 *
 * For a real-time configuration generator and various demos
 * @see https://timellenberger.com/particles
 */

var ParticleCanvas = function ParticleCanvas(_ref) {
  var config = _ref.config;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      clientSide = _useState2[0],
      setClientSide = _useState2[1];

  React.useEffect(function () {
    setClientSide(true);
  }, []);
  if (!clientSide) return null;
  return React__default.createElement(reactThreeFiber.Canvas, {
    gl: {
      antialias: Object.prototype.hasOwnProperty.call(config, 'antialias') ? config.antialias : initialConfig.antialias
    }
  }, React__default.createElement(ParticleField, merge({}, initialConfig, config)));
};

ParticleCanvas.defaultProps = {
  config: {}
};
var defaultConfig = _objectSpread({}, initialConfig);

exports.default = ParticleCanvas;
exports.defaultConfig = defaultConfig;
//# sourceMappingURL=index.cjs.js.map
